<script>
/**
 * <lazyload-image>
 * HTMLImageElement extension for lazy loading.
 * http://github.com/1000ch/lazyload-image
 *
 * Copyright 1000ch
 * licensed under the MIT license.
 */
class LazyloadImage extends Image {
  constructor(width, height) {
    super(width, height);

    this.original = this.currentSrc || this.src;
    this.src = LazyloadImage.FALLBACK_IMAGE;
    this.offset = Number(this.getAttribute('offset')) || 0;
    this.visibleChanged = this.visibleChanged.bind(this);
    this.observer = new IntersectionObserver(this.visibleChanged, {
      rootMargin: `${this.offset}px`
    });
  }

  static get FALLBACK_IMAGE() {
    return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAEElEQVR42gEFAPr/AP///wAI/AL+Sr4t6gAAAABJRU5ErkJggg==';
  }

  static get observedAttributes() {
    return [
      'offset'
    ];
  }

  connectedCallback() {
    this.observer.observe(this);
  }

  disconnectedCallback() {
    this.observer.unobserve(this);
  }

  visibleChanged(changes) {
    for (let change of changes) {
      let intersectionRect = change.intersectionRect;
      if (intersectionRect.height * intersectionRect.width > 0) {
        this.addEventListener('load', () => {
          this.observer.unobserve(this);
        });
        this.addEventListener('error', () => {
          this.removeAttribute('srcset');
          this.src = LazyloadImage.FALLBACK_IMAGE;
          this.observer.unobserve(this);
        });
        this.src = this.original;
        break;
      }
    }
  }

  attributeChangedCallback(name, oldValue, newValue) {
    switch (name) {
      case 'offset':
        this.offset = newValue;
        this.observer.unobserve(this);
        this.observer = new IntersectionObserver(this.visibleChanged, {
          rootMargin: `${this.offset}px`
        });
        this.observer.observe(this);
        break;
    }
  }
}

customElements.define('lazyload-image', LazyloadImage, {
  extends: 'img'
});
</script>
